local _shutter_module = require("shutter.shutter")

local _camera_movement_speed = 5

local _prehash_table =
{
	message_acquire_input_focus = hash("acquire_input_focus"),
	mouse_wheel_up = hash("mouse_wheel_up"),
	mouse_wheel_down = hash("mouse_wheel_down"),
	key_w = hash("key_w"),
	key_a = hash("key_a"),
	key_s = hash("key_s"),
	key_d = hash("key_d"),
	key_q = hash("key_q"),
	key_f = hash("key_f"),
	key_space = hash("key_space"),
	key_esc = hash("key_esc"),

	-- Child camera object in the main collection.
	-- main:/camera_parent/camera
	camera_object = hash("/camera"),

	-- main:/cube
	cube_object = hash("/cube")
}

local _input_table =
{
	key_w = 0,
	key_a = 0,
	key_s = 0,
	key_d = 0,
	key_e = 0,
	key_q = 0,
	screen_dx = 0,
	screen_dy = 0
}

function init()
	msg.post(msg.url(), _prehash_table.message_acquire_input_focus)

	window.set_mouse_lock(true)

	go.animate(_prehash_table.cube_object, "euler.x", go.PLAYBACK_LOOP_PINGPONG, 360, go.EASING_INOUTQUAD, 10)
	go.animate(_prehash_table.cube_object, "euler.y", go.PLAYBACK_LOOP_PINGPONG, 360, go.EASING_INOUTQUAD, 15)
	go.animate(_prehash_table.cube_object, "euler.z", go.PLAYBACK_LOOP_PINGPONG, 360, go.EASING_INOUTQUAD, 20)
end

function update(_, dt)
	-- Rotate the camera.
	local rotation = go.get_rotation(_prehash_table.camera_object)
	rotation = rotation * vmath.quat_rotation_x(_input_table.screen_dy * 0.002)
	rotation = rotation * vmath.quat_rotation_y(_input_table.screen_dx * -0.002)
	go.set_rotation(rotation, _prehash_table.camera_object)

	-- Restrict looking up and down to 89 degrees.
	local euler_x = go.get(_prehash_table.camera_object, "euler.x")
	if euler_x > 89 then
		go.set(_prehash_table.camera_object, "euler.x", 89)
	elseif euler_x < -89 then
		go.set(_prehash_table.camera_object, "euler.x", -89)
	end

	-- Move the camera.
	local absolute_movement_velocity = vmath.vector3(_input_table.key_a + _input_table.key_d, 0, _input_table.key_w + _input_table.key_s) * _camera_movement_speed * dt
	local relative_movement_velocity = vmath.rotate(rotation, absolute_movement_velocity)
	local position = go.get_position(_prehash_table.camera_object)
	go.set_position(position + relative_movement_velocity, _prehash_table.camera_object)

	_input_table.screen_dx = 0
	_input_table.screen_dy = 0
end

function on_input(_, action_id, action)
	-- Cache camera data.
	local camera = _shutter_module.camera_table[_prehash_table.camera_object]

	-- Move the mouse to rotate the camera.
	if not action_id then
		_input_table.screen_dx = action.screen_dx
		_input_table.screen_dy = action.screen_dy

	elseif action.pressed then
		-- Scroll the mouse wheel to zoom the camera.
		if action_id == _prehash_table.mouse_wheel_up then
			camera.field_of_view = vmath.clamp(camera.field_of_view - 20, 30, 150)
		elseif action_id == _prehash_table.mouse_wheel_down then
			camera.field_of_view = vmath.clamp(camera.field_of_view + 20, 30, 150)

		-- Press WASD to move the camera.
		elseif action_id == _prehash_table.key_w then
			_input_table.key_w = -1
		elseif action_id == _prehash_table.key_a then
			_input_table.key_a = -1
		elseif action_id == _prehash_table.key_s then
			_input_table.key_s = 1
		elseif action_id == _prehash_table.key_d then
			_input_table.key_d = 1

		-- Press the Q key to rotate the camera toward the cube object.
	elseif action_id == _prehash_table.key_q then
			-- This implementation sometimes fails after flying around the scene.
			-- I have to learn more about how quaternions work in order to get this right.
			local cube_position = go.get_position(_prehash_table.cube_object)
			local camera_position = go.get_position(_prehash_table.camera_object)
			local camera_to_cube = vmath.normalize(cube_position - camera_position)
			local rotation = vmath.conj(vmath.quat_matrix4(vmath.matrix4_look_at(camera_position, camera_to_cube, vmath.vector3(0, 1, 0))))
			go.set_rotation(rotation, _prehash_table.camera_object)

		-- Press the F key to swap camera behaviors.
		elseif action_id == _prehash_table.key_f then
			if camera.behavior == _shutter_module.center_behavior then
				camera.behavior = _shutter_module.expand_behavior
			elseif camera.behavior == _shutter_module.expand_behavior then
				camera.behavior = _shutter_module.stretch_behavior
			elseif camera.behavior == _shutter_module.stretch_behavior then
				camera.behavior = _shutter_module.center_behavior
			end

		-- Press the space bar to shake the camera.
		elseif action_id == _prehash_table.key_space then
			-- This example shakes the parent of the camera object 20 times in a pingpong fashion,
			-- where each pingpong lasts for 0.05 seconds,
			-- where each pingpong displaces the camera by 0.5 units,
			-- where each pingpong decreases the duration (0.05) and radius (0.5) by a factor of 0.9.
			-- These last two optional arguments apply a smoothing effect as the shake comes to an end.
			-- Note that shaking the parent object allows us to continue moving the camera (child object) simultaneously.
			_shutter_module.shake(_prehash_table.camera_object, true, 20, 0.05, 0.5, 0.9, 0.9)

		elseif action_id == _prehash_table.key_esc then
			if window.get_mouse_lock() then
				window.set_mouse_lock(false)
			else
				sys.exit(0)
			end
		end

	elseif action.released then
		-- Release WASD to stop moving the camera.
		if action_id == _prehash_table.key_w then
			_input_table.key_w = 0
		elseif action_id == _prehash_table.key_a then
			_input_table.key_a = 0
		elseif action_id == _prehash_table.key_s then
			_input_table.key_s = 0
		elseif action_id == _prehash_table.key_d then
			_input_table.key_d = 0
		end
	end
end